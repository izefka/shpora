import React from "react";

function Memo() {
  return (
    <>
      <h2>React.memo</h2>
      <p>React.memo — это компонент высшего порядка.</p>
      <p>
        Если ваш компонент всегда рендерит одно и то же при неменяющихся
        пропсах, вы можете обернуть его в вызов React.memo для повышения
        производительности в некоторых случаях, мемоизируя тем самым результат.
        Это значит, что React будет использовать результат последнего рендера,
        избегая повторного рендеринга. React.memo затрагивает только изменения
        пропсов. Если функциональный компонент обёрнут в React.memo и использует
        useState, useReducer или useContext, он будет повторно рендериться при
        изменении состояния или контекста. По умолчанию он поверхностно
        сравнивает вложенные объекты в объекте props. Если вы хотите
        контролировать сравнение, вы можете передать свою функцию сравнения в
        качестве второго аргумента.
      </p>
      <pre>
        <code>{`const MyScotchyComponent = React.memo(function MyComponent(props) {
  // отображается только, если изменилось свойство!
});
 
// может также быть функция стрелок es6
const OtherScotchy = React.memo(props => {
  return <div>my memoized component</div>;
});
 
// и даже еще короче с неявным возвращением
const ImplicitScotchy = React.memo(props => (
  <div>implicit memoized component</div>
));`}</code>
      </pre>
      <p>useMemo</p>
      <p>
        Передайте «создающую» функцию и массив зависимостей. useMemo будет
        повторно вычислять мемоизированное значение только тогда, когда значение
        какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать
        дорогостоящих вычислений при каждом рендере. Помните, что функция,
        переданная useMemo, запускается во время рендеринга. Не делайте там
        ничего, что вы обычно не делаете во время рендеринга. Например, побочные
        эффекты принадлежат useEffect, а не useMemo. Возвращает значение.
      </p>
      <pre>
        <code>{`const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);`}</code>
      </pre>
    </>
  );
}

export default Memo;
